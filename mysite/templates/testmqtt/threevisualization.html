<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Testing 2D visualization</title>
    {% load static %}
    <script type='text/javascript' src="{% static 'js/jquery.min.js' %}" ></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script src="http://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <link rel="stylesheet" type="text/css" href="{% static 'css/canvasTest.css' %}">
</head>
<body>
    <div class="page-container">
        <div class="left-container">
            <canvas></canvas>
            <div>
                <a href="{% url 'dashboard' %}">Return to Dashboard</a>
            </div>
        </div>
        <div class="right-container">
            <div class="sensor-header">
                <span>Existing Array Name</span>
                <span><input class="array-name" type="text"></span>
                <span><input class="animation-toggle" type="button" value="Toggle Animation"></span>
            </div>
            <div class="sensor-header">
                <span>Floor Count</span>
                <span><input class="num-input" id="floor-count" type="number" min="1" value="1"></span>
                <span>Nodes Per Floor</span>
                <span><input class="num-input" id="nodes-floor-count" type="number" min="4" value="4"></span>
                <span><input class="submit-temp" type="button" value="Generate New Nodes"></span>
            </div>
            <div class="point-list">
                <div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>
            </div>
        </div>
    </div>
    <div id="nodeModal" class="modal fade" role="dialog" data-backdrop="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 class="modal-title">Connected Nodes</h4>
                </div>
                <div class="modal-body">
                    <div class="connected-node-options"></div>
                    <input type="hidden" id="current-node-parent" value="0">
                    <input type="button" value="Update Connected Nodes" onclick="updateConnectedNodes()">
                </div>
            </div>
        </div>
    </div>
    <script>
        var canvas = document.querySelector('canvas');
        var canWidth = 500;
        var canHeight = 500;
        canvas.width = canWidth;
        canvas.height = canHeight;
        var arrayName = '';
        var pointArray = [];
        var geometryLines = [];
        var targetList = [];
        var isAnimating = false;
        var floorCount = 0;

        var renderer = new THREE.WebGLRenderer({ canvas: canvas });
        scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(50, 1, 1, 10000);
	    camera.position.set(0, 0, 1000);

	    var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

	    controls = new THREE.OrbitControls (camera,renderer.domElement );
        controls.update();

        var geometry = new THREE.BoxGeometry( 10, 10, 10 );
        var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
        var materialline = new THREE.LineBasicMaterial({color: 0xA35F77});
        var geometryline = new THREE.Geometry();

        /*
        setInterval(function(){
            $.ajax({url: '/updateCanvasPoints',
                success: function(result){
                    for(var i = 0; i < result.data.length; i++){
                        for(var j = 0; j < pointArray.length; j++){
                            if(pointArray[j].name === result.data[i].pointName){
                                pointArray[j].updateCoordinates(result.data[i].xCoordinate, result.data[i].yCoordinate, result.data[i].zCoordinate);
                            }
                        }
                    }
                }
            });
        }, 1000);
        */

        function Point(name, x, y, z){
            this.name = name;
            this.x = x*10;
            this.y = y*10;
            this.z = z*10;
            this.xanim = this.x;
            this.yanim = this.y;
            this.zanim = this.z;
            this.range = 3;
            this.dx = 0.1;
            this.right = true;
            this.up = true;
            this.connectedPoints = [];
            this.cube;
            this.floor = 0;

            this.updateCoordinates = function(newX, newY, newZ){
                isAnimating = false;
                var numX = parseInt(newX)
                var numY = parseInt(newY)
                var numZ = parseInt(newZ)
                if(this.x != numX){
                    this.x = numX;
                    this.xanim = this.x;
                 }
                if(this.y != numY){
                    this.y = numY;
                    this.yanim = this.y;
                }
                if(this.z != numZ){
                    this.z = numZ;
                    this.zanim = this.z;
                }
            }

            this.setDirection = function(){
                //logic for cw or ccw movement (placeholder movement)
                if(this.z > 0){ //cw
                    if(this.y > 0){ //right
                        this.right = true;
                    }
                    else{ //left
                        this.right = false;
                    }
                }
                else if(this.z < 0){ //ccw
                    if(this.y > 0){ //left
                        this.right = false;
                    }
                    else{ //right
                        this.right = true;
                    }
                }
                else{ //stationary
                    this.dx = 0;
                }
            }

            this.draw = function(){
                this.cube = new THREE.Mesh( geometry, material );
                this.cube.position.setX(this.xanim);
                this.cube.position.setY(this.y);
                this.cube.position.setZ(this.z);
                this.cube.name = this.name;
                scene.add( this.cube );
                targetList.push(this.cube);
            }

            this.drawLines = function(){
                for(var cpi = 0; cpi < this.connectedPoints.length; cpi++){
                    for(var ari = 0; ari < pointArray.length; ari++){
                        if(pointArray[ari].name === this.connectedPoints[cpi]){
                            let newLine = new Line(this, pointArray[ari]);
                            newLine.checkLines();
                        }
                    }
                }
            }

            this.update = function(){
                if(isAnimating){
                    if(this.right){
                        if(this.xanim + this.dx <= this.x + this.range) this.xanim += this.dx;
                        else this.right = false;
                    }
                    else{
                        if(this.xanim - this.dx >= this.x - this.range) this.xanim -= this.dx;
                        else this.right = true;
                    }
                    this.cube.position.setX(this.xanim);
                }
                else{
                    //this.xanim = this.x;
                    this.cube.position.setX(this.xanim);
                    this.cube.position.setY(this.yanim);
                    this.cube.position.setZ(this.zanim);
                }
            }
        }

        function Line(p1, p2){
            this.point1 = p1;
            this.point2 = p2;
            this.geometryLine;

            this.checkLines = function(){
                var lineExists = false;
                for(var lineIndex = 0; lineIndex < geometryLines.length; lineIndex++){
                    var comparePoint1 = geometryLines[lineIndex].point1.name;
                    var comparePoint2 = geometryLines[lineIndex].point2.name;
                    if(this.point1.name === comparePoint1 && this.point2.name === comparePoint2){
                        lineExists = true;
                    }
                    else if(this.point1.name === comparePoint2 && this.point2.name === comparePoint1){
                        lineExists = true;
                    }
                }
                if(!lineExists){
                    this.drawLine();
                }
            }

            this.drawLine = function(){
                this.geometryLine = new THREE.Geometry();
                this.geometryLine.vertices.push(this.point1.cube.position, this.point2.cube.position)
                var line = new THREE.Line( this.geometryLine, materialline );
                geometryLines.push(this);
                scene.add(line);
            }


        }

        function init(){
            for(var k = 0; k < pointArray.length; k++){
                pointArray[k].draw();
            }
            for(var k = 0; k < pointArray.length; k++){
                pointArray[k].drawLines();
            }
        }

        function animate(){
            requestAnimationFrame( animate );
            controls.update();
            for(var g = 0; g < geometryLines.length; g++){
                geometryLines[g].geometryLine.verticesNeedUpdate = true;
            }
            for(var p = 0; p < pointArray.length; p++){
                pointArray[p].update();
            }
            renderer.render( scene, camera );
        }

        function updateExistingArray(){ //"existing" is in the context of the SQLite database
            {% for node in nodes %}
                if('{{node.nodeName}}' === arrayName){
                    {% for point in node.point_set.all %}
                        var point = new Point('{{point.pointName}}', {{point.xCoordinate}}, {{point.yCoordinate}}, {{point.zCoordinate}});
                        point.setDirection();
                        {% for connectedNode in point.connectedNodes.all %}
                            point.connectedPoints.push('{{connectedNode}}');
                        {% endfor %}
                        point.range = Math.abs(({{point.yCoordinate}} / Math.sqrt(3))/2);
                        point.dx = point.range/50;
                        pointArray.push(point);
                        $(".point-list").append("<div>{{point.pointName}}</div>");
                    {% endfor %}
                }
            {% endfor %}
            console.log(pointArray)
        }

        function generateArray(){
            var numFloors = $("#floor-count").val();
            floorCount = parseInt(numFloors);
            var numNodes = $("#nodes-floor-count").val();
            for(var i = 0; i < numFloors; i++){
                createDefaultNodes(i);
                for(var j = 4; j < numNodes; j++){
                    var point = new Point('new(' + pointArray.length + ')', 0, (i)*20, 0);
                    point.setDirection();
                    point.floor = i + 1;
                    pointArray.push(point);
                }
                floorDetails(i);
            }
            $(".point-list").append('<div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>');
        }

        function addFloor(){
            $("#add-floor").remove();
            floorDetails(floorCount);
            floorCount++;
            $(".point-list").append('<div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>');
        }

        function addNode(floorNum){
            var point = new Point('new(' + pointArray.length + ')', 0, (floorNum-1)*20, 0);
            point.setDirection();
            point.range = Math.abs(((floorNum-1)*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.floor = floorNum;
            pointArray.push(point);

            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            init();
            updateConnectedNodes();

            $(".floor-" + floorNum + "-content").empty();
            for(var fd = 0; fd < pointArray.length; fd++){
                if(floorNum === pointArray[fd].floor) nodeDetails(fd);
            }
            $(".floor-" + floorNum + "-content").append('<div class="node-container" id="add-node-' + floorNum + '"><input type="button" value="Add a Node" onClick="addNode(' + floorNum + ')"></div>');
        }

        function createDefaultNodes(floor){
            var point = new Point('NW' + (floor+1), -10, floor*20, -10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NE' + (floor+1));
            point.connectedPoints.push('SW' + (floor+1));
            if(floor) point.connectedPoints.push('NW' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('NE' + (floor+1), 10, floor*20, -10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NW' + (floor+1));
            point.connectedPoints.push('SE' + (floor+1));
            if(floor) point.connectedPoints.push('NE' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('SE' + (floor+1), 10, floor*20, 10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NE' + (floor+1));
            point.connectedPoints.push('SW' + (floor+1));
            if(floor) point.connectedPoints.push('SE' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('SW' + (floor+1), -10, floor*20, 10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NW' + (floor+1));
            point.connectedPoints.push('SE' + (floor+1));
            if(floor) point.connectedPoints.push('SW' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);
        }

        function floorDetails(floorNum){
            const floorVal = floorNum + 1;
            const floorDiv= '<div class="floor-container">' +
                                'Floor ' + floorVal +
                                '<div class="floor-' + floorVal + '-content"></div>'
                            '</div>';
            $(".point-list").append(floorDiv);
            for(var fd = 0; fd < pointArray.length; fd++){
                if(floorVal === pointArray[fd].floor) nodeDetails(fd);
            }
            $(".floor-" + floorVal + "-content").append('<div class="node-container" id="add-node-' + floorVal + '"><input type="button" value="Add a Node" onClick="addNode(' + floorVal + ')"></div>');
        }

        function nodeDetails(arrayIndex){
            const node = pointArray[arrayIndex];
            const nodeDiv = '<div class="node-container">' +
                                '<span><input id="nodename-' + arrayIndex + '" type="text" value="' + node.name + '"></span>' +
                                '<span><input type="button" value="Update Node" onclick="updateNodeDetails(' + arrayIndex + ')"></span>' +
                                '<span><input type="button" value="Delete Node" onclick"deleteNode(' + arrayIndex + ')"></span>' +
                                '<div>' +
                                    '<span>X<input id="nodex-' + arrayIndex + '" class="pos-input" type="number" value="' + node.x + '"></span>' +
                                    '<span>Y<input id="nodey-' + arrayIndex + '" class="pos-input" type="number" value="' + node.y + '"></span>' +
                                    '<span>Z<input id="nodez-' + arrayIndex + '" class="pos-input" type="number" value="' + node.z + '"></span>' +
                                    '<span><input type="button" value="Configure Connected Nodes" onclick="setConnectedNodes(' + arrayIndex + ')"></span>' +
                                '</div>' +
                            '</div>'
            $(".floor-" + node.floor + "-content").append(nodeDiv);
        }

        function updateNodeDetails(arrayIndex){
            const xString = "#nodex-" + arrayIndex;
            const yString = "#nodey-" + arrayIndex;
            const zString = "#nodez-" + arrayIndex;
            const nameString = "#nodename-" + arrayIndex;
            const xNew = parseInt($(xString).val());
            const yNew = parseInt($(yString).val());
            const zNew = parseInt($(zString).val());
            const newName = $(nameString).val();
            pointArray[arrayIndex].updateCoordinates(xNew, yNew, zNew);
            changeNodeName(arrayIndex, newName);
        }

        function changeNodeName(arrayIndex, newName){
            var oldName = pointArray[arrayIndex].name;
            for(var i = 0; i < pointArray.length; i++){
                for(var j = 0; j < pointArray[i].connectedPoints.length; j++){
                    if(pointArray[i].connectedPoints[j] === oldName) pointArray[i].connectedPoints[j] = newName;
                }
            }
            pointArray[arrayIndex].name = newName;
        }

        function deleteNode(arrayIndex){
        }

        function setConnectedNodes(arrayIndex){
            $('#current-node-parent').attr('value', arrayIndex);
            $(".connected-node-options").empty();
            $(".connected-node-options").append('Parent Node: ' + pointArray[arrayIndex].name + '<br>');
            for(var n = 0; n < pointArray.length; n++){
                if(n != arrayIndex){
                    var name = pointArray[n].name;
                    var checkboxString = '<input type="checkbox" name="chk[]" value="' + name + '">' + name + '<br>';
                    $(".connected-node-options").append(checkboxString);
                }
            }
            var connected = pointArray[arrayIndex].connectedPoints;
            $('input[name="chk[]"]').each(function(){
                var isChecked = false;
                var reference = $(this);
                for(var n = 0; n < connected.length; n++){
                    if(connected[n] === reference.val()) isChecked = true;
                }
                if(isChecked) reference.prop('checked', true);
            })
            $("#nodeModal").modal();
        }

        function updateConnectedNodes(){
            var parentNode = parseInt($('#current-node-parent').val());
            var newConnected = []
            $('input[name="chk[]"]:checked').each(function(){
                newConnected.push($(this).val())
            })
            pointArray[parentNode].connectedPoints = newConnected;
            for(var i = 0; i < pointArray.length; i++){
                for(var j = 0; j < newConnected.length; j++){
                    if(pointArray[i].name === newConnected[j]){
                        var alreadyConnected = false;
                        for(var k = 0; k < pointArray[i].connectedPoints.length; k++){
                            if(pointArray[i].connectedPoints[k] === pointArray[parentNode].name) alreadyConnected = true;
                        }
                        if(!alreadyConnected){
                            pointArray[i].connectedPoints.push(pointArray[parentNode].name);
                        }
                    }
                }
            }
            geometryLines = [];
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            init();
            $("#nodeModal").modal('hide');
        }

        function onDocumentMouseDown(event){
            mouse.x = ( (event.clientX - renderer.domElement.offsetLeft) / renderer.domElement.width) * 2 - 1;
            mouse.y = - ( (event.clientY - renderer.domElement.offsetTop) / renderer.domElement.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(targetList);

            if (intersects.length > 0) {
                isAnimating = false;
                console.log(intersects[0].object.name);
                setHighlight(intersects[0].object);
            }
        }

        function setHighlight(object){
            scene.remove(scene.getObjectByName('highlight'));

            var highlightGeometry = new THREE.SphereGeometry(20, 32, 32);
            var highlightMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            highlightMaterial.transparent = true;
            highlightMaterial.opacity = 0.5;

            var highlightSphere = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlightSphere.position.setX(object.position.x);
            highlightSphere.position.setY(object.position.y);
            highlightSphere.position.setZ(object.position.z);
            highlightSphere.name = 'highlight';

            scene.add(highlightSphere);
        }

        $(".array-name").on('keypress', function(e){
            if(e.which == 13){
                arrayName = $(".array-name").val();
                $(".point-list").empty();
                pointArray = [];
                geometryLines = [];
                targetList = [];
                while(scene.children.length > 0){
                    scene.remove(scene.children[0]);
                }
                updateExistingArray();
                init();
            }
        });

        $(".submit-temp").on('click', function(e){
            $(".point-list").empty();
            pointArray = [];
            geometryLines = [];
            targetList = [];
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            generateArray();
            init();
        });

        $(".animation-toggle").on('click', function(e){
            if(!isAnimating) scene.remove(scene.getObjectByName('highlight'));
            isAnimating = !isAnimating;
        });

        canvas.addEventListener('click', onDocumentMouseDown, false);
        animate();
    </script>
</body>
</html>