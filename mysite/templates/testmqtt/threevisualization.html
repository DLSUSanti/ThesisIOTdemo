<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Testing 2D visualization</title>
    {% load static %}
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="{% static 'css/canvasTest.css' %}">
    <script type='text/javascript' src="{% static 'js/jquery.min.js' %}" ></script>
    <script src="http://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="page-container">
        <div class="left-container">
            <canvas></canvas>
            <div>help text</div>
        </div>
        <div class="right-container">
            <div class="sensor-header">
                <span>Existing Array Name</span>
                <span><input class="array-name" type="text"></span>
                <span><input class="animation-toggle" type="button" value="Toggle Animation"></span>
            </div>
            <div class="sensor-header">
                <span>Floor Count</span>
                <span><input class="num-input" id="floor-count" type="number" min="1" value="1"></span>
                <span>Nodes Per Floor</span>
                <span><input class="num-input" id="nodes-floor-count" type="number" min="4" value="4"></span>
                <span><input class="submit-temp" type="button" value="Generate New Nodes"></span>
            </div>
            <div class="point-list"></div>
        </div>
    </div>
    <script>
        var canvas = document.querySelector('canvas');
        var canWidth = 500;
        var canHeight = 500;
        canvas.width = canWidth;
        canvas.height = canHeight;
        var arrayName = '';
        var pointArray = [];
        var geometryLines = [];
        var isAnimating = false;

        var renderer = new THREE.WebGLRenderer({ canvas: canvas });
        scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(50, 1, 1, 10000);
	    camera.position.set(0, 0, 1000);

	    controls = new THREE.OrbitControls (camera,renderer.domElement );
        controls.update();

        var geometry = new THREE.BoxGeometry( 10, 10, 10 );
        var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
        var materialline = new THREE.LineBasicMaterial({color: 0xA35F77});
        var geometryline = new THREE.Geometry();

        /*
        setInterval(function(){
            $.ajax({url: '/updateCanvasPoints',
                success: function(result){
                    for(var i = 0; i < result.data.length; i++){
                        for(var j = 0; j < pointArray.length; j++){
                            if(pointArray[j].name === result.data[i].pointName){
                                pointArray[j].updateCoordinates(result.data[i].xCoordinate, result.data[i].yCoordinate, result.data[i].zCoordinate);
                            }
                        }
                    }
                }
            });
        }, 1000);
        */

        function Point(name, x, y, z){
            this.name = name;
            this.x = x*10;
            this.y = y*10;
            this.z = z*10;
            this.xanim = this.x;
            this.yanim = this.y;
            this.zanim = this.z;
            this.range = 3;
            this.dx = 0.1;
            this.right = true;
            this.up = true;
            this.connectedPoints = [];
            this.cube;
            this.floor = 0;

            this.updateCoordinates = function(newX, newY, newZ){
                isAnimating = false;
                var numX = parseInt(newX)
                var numY = parseInt(newY)
                var numZ = parseInt(newZ)
                if(this.x != numX){
                    this.x = numX;
                    this.xanim = this.x;
                 }
                if(this.y != numY){
                    this.y = numY;
                    this.yanim = this.y;
                }
                if(this.z != numZ){
                    this.z = numZ;
                    this.zanim = this.z;
                }
            }

            this.setDirection = function(){
                //logic for cw or ccw movement (placeholder movement)
                if(this.z > 0){ //cw
                    if(this.y > 0){ //right
                        this.right = true;
                    }
                    else{ //left
                        this.right = false;
                    }
                }
                else if(this.z < 0){ //ccw
                    if(this.y > 0){ //left
                        this.right = false;
                    }
                    else{ //right
                        this.right = true;
                    }
                }
                else{ //stationary
                    this.dx = 0;
                }
            }

            this.draw = function(){
                this.cube = new THREE.Mesh( geometry, material );
                this.cube.position.setX(this.xanim);
                this.cube.position.setY(this.y);
                this.cube.position.setZ(this.z);
                scene.add( this.cube );
            }

            this.drawLines = function(){
                for(var cpi = 0; cpi < this.connectedPoints.length; cpi++){
                    for(var ari = 0; ari < pointArray.length; ari++){
                        if(pointArray[ari].name === this.connectedPoints[cpi]){
                            let newLine = new Line(this, pointArray[ari]);
                            newLine.checkLines();
                        }
                    }
                }
            }

            this.update = function(){
                if(isAnimating){
                    if(this.right){
                        if(this.xanim + this.dx <= this.x + this.range) this.xanim += this.dx;
                        else this.right = false;
                    }
                    else{
                        if(this.xanim - this.dx >= this.x - this.range) this.xanim -= this.dx;
                        else this.right = true;
                    }
                    this.cube.position.setX(this.xanim);
                }
                else{
                    this.xanim = this.x;
                    this.cube.position.setX(this.xanim);
                    this.cube.position.setY(this.yanim);
                    this.cube.position.setZ(this.zanim);
                }
            }
        }

        function Line(p1, p2){
            this.point1 = p1;
            this.point2 = p2;
            this.geometryLine;

            this.checkLines = function(){
                var lineExists = false;
                for(var lineIndex = 0; lineIndex < geometryLines.length; lineIndex++){
                    var comparePoint1 = geometryLines[lineIndex].point1.name;
                    var comparePoint2 = geometryLines[lineIndex].point2.name;
                    if(this.point1.name === comparePoint1 && this.point2.name === comparePoint2){
                        lineExists = true;
                    }
                    else if(this.point1.name === comparePoint2 && this.point2.name === comparePoint1){
                        lineExists = true;
                    }
                }
                if(!lineExists){
                    this.drawLine();
                }
            }

            this.drawLine = function(){
                this.geometryLine = new THREE.Geometry();
                this.geometryLine.vertices.push(this.point1.cube.position, this.point2.cube.position)
                var line = new THREE.Line( this.geometryLine, materialline );
                geometryLines.push(this);
                scene.add(line);
            }


        }

        function init(){
            for(var k = 0; k < pointArray.length; k++){
                pointArray[k].draw();
            }
            for(var k = 0; k < pointArray.length; k++){
                pointArray[k].drawLines();
            }
        }

        function animate(){
            requestAnimationFrame( animate );
            controls.update();
            for(var g = 0; g < geometryLines.length; g++){
                geometryLines[g].geometryLine.verticesNeedUpdate = true;
            }
            for(var p = 0; p < pointArray.length; p++){
                pointArray[p].update();
            }
            renderer.render( scene, camera );
        }

        function updateExistingArray(){ //"existing" is in the context of the SQLite database
            {% for node in nodes %}
                if('{{node.nodeName}}' === arrayName){
                    {% for point in node.point_set.all %}
                        var point = new Point('{{point.pointName}}', {{point.xCoordinate}}, {{point.yCoordinate}}, {{point.zCoordinate}});
                        point.setDirection();
                        {% for connectedNode in point.connectedNodes.all %}
                            point.connectedPoints.push('{{connectedNode}}');
                        {% endfor %}
                        point.range = Math.abs(({{point.yCoordinate}} / Math.sqrt(3))/2);
                        point.dx = point.range/50;
                        pointArray.push(point);
                        $(".point-list").append("<div>{{point.pointName}}</div>");
                    {% endfor %}
                }
            {% endfor %}
            console.log(pointArray)
        }

        function generateArray(){
            var numFloors = $("#floor-count").val();
            var numNodes = $("#nodes-floor-count").val();
            for(var i = 0; i < numFloors; i++){
                createDefaultNodes(i);
                for(var j = 4; j < numNodes; j++){
                    var point = new Point('test', 0, (i)*20, 0);
                    point.setDirection();
                    point.floor = i + 1;
                    pointArray.push(point);
                }
                floorDetails(i);
            }
            $(".point-list").append('<div class="floor-container">Add a floor...</div>')
        }

        function createDefaultNodes(floor){
            var point = new Point('NW' + (floor+1), -10, floor*20, -10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NE' + (floor+1));
            point.connectedPoints.push('SW' + (floor+1));
            if(floor) point.connectedPoints.push('NW' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('NE' + (floor+1), 10, floor*20, -10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NW' + (floor+1));
            point.connectedPoints.push('SE' + (floor+1));
            if(floor) point.connectedPoints.push('NE' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('SE' + (floor+1), 10, floor*20, 10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NE' + (floor+1));
            point.connectedPoints.push('SW' + (floor+1));
            if(floor) point.connectedPoints.push('SE' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('SW' + (floor+1), -10, floor*20, 10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NW' + (floor+1));
            point.connectedPoints.push('SE' + (floor+1));
            if(floor) point.connectedPoints.push('SW' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);
        }

        function floorDetails(floorNum){
            const floorVal = floorNum + 1;
            const floorDiv= '<div class="floor-container">' +
                                'Floor ' + floorVal +
                                '<div class="floor-' + floorVal + '-content"></div>'
                            '</div>';
            $(".point-list").append(floorDiv);
            for(var fd = 0; fd < pointArray.length; fd++){
                if(floorVal === pointArray[fd].floor) nodeDetails(fd);
            }
            $(".floor-" + floorVal + "-content").append('<div class="node-container">Add a Node...</div>');
        }

        function nodeDetails(arrayIndex){
            const node = pointArray[arrayIndex];
            const nodeDiv = '<div class="node-container">' +
                                '<span>' + node.name + '</span><span><input type="button" value="Update Node" onclick="updateNodeDetails(' + arrayIndex + ')"></span>' +
                                '<div>' +
                                    '<span>X<input id="nodex-' + arrayIndex + '" class="pos-input" type="number" value="' + node.x + '"></span>' +
                                    '<span>Y<input id="nodey-' + arrayIndex + '" class="pos-input" type="number" value="' + node.y + '"></span>' +
                                    '<span>Z<input id="nodez-' + arrayIndex + '" class="pos-input" type="number" value="' + node.z + '"></span>' +
                                    '<span><button value="' + arrayIndex + '">Configure Connected Nodes</button></span>' +
                                '</div>' +
                            '</div>'
            $(".floor-" + node.floor + "-content").append(nodeDiv);
        }

        function updateNodeDetails(arrayIndex){
            const xString = "#nodex-" + arrayIndex;
            const yString = "#nodey-" + arrayIndex;
            const zString = "#nodez-" + arrayIndex;
            const xNew = parseInt($(xString).val());
            const yNew = parseInt($(yString).val());
            const zNew = parseInt($(zString).val());
            pointArray[arrayIndex].updateCoordinates(xNew, yNew, zNew);
        }

        $(".array-name").on('keypress', function(e){
            if(e.which == 13){
                arrayName = $(".array-name").val();
                $(".point-list").empty();
                pointArray = [];
                geometryLines = [];
                while(scene.children.length > 0){
                    scene.remove(scene.children[0]);
                }
                updateExistingArray();
                init();
            }
        });

        $(".submit-temp").on('click', function(e){
            $(".point-list").empty();
            pointArray = [];
            geometryLines = [];
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            generateArray();
            init();
        });

        $(".animation-toggle").on('click', function(e){
            isAnimating = !isAnimating;
        });

        animate();

    </script>
</body>
</html>