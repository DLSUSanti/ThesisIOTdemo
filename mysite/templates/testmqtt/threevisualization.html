<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Testing 2D visualization</title>
    {% load static %}
    <script type='text/javascript' src="{% static 'js/jquery.min.js' %}" ></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
    <script src="http://threejs.org/build/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <link rel="stylesheet" type="text/css" href="{% static 'css/canvasTest.css' %}">
    <script type='text/javascript' src="{% static 'js/Point.js' %}" ></script>
    <script type='text/javascript' src="{% static 'js/Line.js' %}" ></script>
    <script type='text/javascript' src="{% static 'js/AnimationFrame.js' %}" ></script>
</head>
<body>
    <div class="page-container">
        <div class="left-container">
            <canvas></canvas>
            <div>
                <div class="slide-container">
                    <input type="range" min="1" max="500" id="time-slider" value="1">
                </div>
                <div class="animation-options">
                    <span><input class="animation-toggle" type="button" value="Play"></span>
                    <span><input class="load-file" type="button" value="Load File"></span>
                </div>
                <div>
                    <span><a href="{% url 'dashboard' %}">Return to Dashboard</a></span>
                </div>
            </div>
        </div>
        <div class="right-container">
            <div class="sensor-header">
                <span>Existing Array Name</span>
                <span><input class="array-name" type="text"></span>
            </div>
            <div class="sensor-header">
                <span>Floor Count</span>
                <span><input class="num-input" id="floor-count" type="number" min="1" value="1"></span>
                <span>Nodes Per Floor</span>
                <span><input class="num-input" id="nodes-floor-count" type="number" min="4" value="4"></span>
                <span><input class="submit-temp" type="button" value="Generate New Nodes"></span>
            </div>
            <div class="point-list">
                <div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>
            </div>
        </div>
    </div>
    <div id="nodeModal" class="modal fade" role="dialog" data-backdrop="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h4 class="modal-title">Connected Nodes</h4>
                </div>
                <div class="modal-body">
                    <div class="connected-node-options"></div>
                    <input type="hidden" id="current-node-parent" value="0">
                    <input type="button" value="Update Connected Nodes" onclick="updateConnectedNodes()">
                </div>
            </div>
        </div>
    </div>
    <script>
        var canvas = document.querySelector('canvas');
        var canWidth = 500;
        var canHeight = 500;
        canvas.width = canWidth;
        canvas.height = canHeight;
        var arrayName = '';

        var pointArray = [];
        var geometryLines = [];
        var targetList = [];

        var floorCount = 0;

        var animationFrames = [];
        var isAnimating = false;
        var currentTime = 1;
        var timeMax = 500;

        var renderer = new THREE.WebGLRenderer({ canvas: canvas });
        scene = new THREE.Scene();
		camera = new THREE.PerspectiveCamera(50, 1, 1, 10000);
	    camera.position.set(0, 0, 1000);

	    var raycaster = new THREE.Raycaster();
        var mouse = new THREE.Vector2();

	    controls = new THREE.OrbitControls (camera,renderer.domElement );
        controls.update();

        var geometry = new THREE.BoxGeometry( 10, 10, 10 );
        var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
        var materialline = new THREE.LineBasicMaterial({color: 0xA35F77});
        var geometryline = new THREE.Geometry();

        function init(){
            for(var k = 0; k < pointArray.length; k++){
                pointArray[k].draw(scene, targetList, geometry, material);
            }
            for(var k = 0; k < pointArray.length; k++){
                pointArray[k].drawLines(pointArray);
            }
        }

        function loadAnimationFile(){
            animationFrames.length = 0;
            currentTime = 1;
            $("#time-slider").val(currentTime);
        }

        function nextFrame(){       //update this
            if(isAnimating){
                if(currentTime < timeMax) currentTime++;
                else currentTime = 1;

                $("#time-slider").val(currentTime);
                for(var p = 0; p < pointArray.length; p++){
                    pointArray[p].update();
                }
            }
        }

        function animate(){     //update this
            requestAnimationFrame( animate );
            controls.update();
            for(var g = 0; g < geometryLines.length; g++){
                geometryLines[g].geometryLine.verticesNeedUpdate = true;
            }
            nextFrame();
            renderer.render( scene, camera );
        }

        function updateExistingArray(){ //"existing" is in the context of the SQLite database
            {% for node in nodes %}
                if('{{node.nodeName}}' === arrayName){
                    {% for point in node.point_set.all %}
                        var point = new Point('{{point.pointName}}', {{point.xCoordinate}}, {{point.yCoordinate}}, {{point.zCoordinate}});
                        point.setDirection();
                        {% for connectedNode in point.connectedNodes.all %}
                            point.connectedPoints.push('{{connectedNode}}');
                        {% endfor %}
                        point.range = Math.abs(({{point.yCoordinate}} / Math.sqrt(3))/2);       //update this
                        point.dx = point.range/50;
                        pointArray.push(point);
                        $(".point-list").append("<div>{{point.pointName}}</div>");
                    {% endfor %}
                }
            {% endfor %}
            console.log(pointArray)
        }

        function generateArray(){
            var numFloors = $("#floor-count").val();
            floorCount = parseInt(numFloors);
            var numNodes = $("#nodes-floor-count").val();
            for(var i = 0; i < numFloors; i++){
                createDefaultNodes(i);
                for(var j = 4; j < numNodes; j++){
                    var point = new Point('new(' + pointArray.length + ')', 0, (i)*20, 0);
                    point.setDirection();
                    point.floor = i + 1;
                    pointArray.push(point);
                }
                floorDetails(i);
            }
            $(".point-list").append('<div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>');
        }

        function addFloor(){
            $("#add-floor").remove();
            floorDetails(floorCount);
            floorCount++;
            $(".point-list").append('<div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>');
        }

        function addNode(floorNum){
            var point = new Point('new(' + pointArray.length + ')', 0, (floorNum-1)*20, 0);
            point.setDirection();
            point.range = Math.abs(((floorNum-1)*20 / Math.sqrt(3))/2);     //update this
            point.dx = point.range/50;
            point.floor = floorNum;
            pointArray.push(point);

            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            init();
            updateConnectedNodes();

            $(".floor-" + floorNum + "-content").empty();
            for(var fd = 0; fd < pointArray.length; fd++){
                if(floorNum === pointArray[fd].floor) nodeDetails(fd);
            }
            $(".floor-" + floorNum + "-content").append('<div class="node-container" id="add-node-' + floorNum + '"><input type="button" value="Add a Node" onClick="addNode(' + floorNum + ')"></div>');
        }

        function createDefaultNodes(floor){
            var point = new Point('NW' + (floor+1), -10, floor*20, -10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);        //update this
            point.dx = point.range/50;
            point.connectedPoints.push('NE' + (floor+1));
            point.connectedPoints.push('SW' + (floor+1));
            if(floor) point.connectedPoints.push('NW' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('NE' + (floor+1), 10, floor*20, -10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NW' + (floor+1));
            point.connectedPoints.push('SE' + (floor+1));
            if(floor) point.connectedPoints.push('NE' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('SE' + (floor+1), 10, floor*20, 10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NE' + (floor+1));
            point.connectedPoints.push('SW' + (floor+1));
            if(floor) point.connectedPoints.push('SE' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);

            var point = new Point('SW' + (floor+1), -10, floor*20, 10);
            point.setDirection();
            point.range = Math.abs((floor*20 / Math.sqrt(3))/2);
            point.dx = point.range/50;
            point.connectedPoints.push('NW' + (floor+1));
            point.connectedPoints.push('SE' + (floor+1));
            if(floor) point.connectedPoints.push('SW' + (floor));
            point.floor = floor + 1;
            pointArray.push(point);
        }

        function floorDetails(floorNum){
            const floorVal = floorNum + 1;
            const floorDiv= '<div class="floor-container">' +
                                'Floor ' + floorVal +
                                '<div class="floor-' + floorVal + '-content"></div>'
                            '</div>';
            $(".point-list").append(floorDiv);
            for(var fd = 0; fd < pointArray.length; fd++){
                if(floorVal === pointArray[fd].floor) nodeDetails(fd);
            }
            $(".floor-" + floorVal + "-content").append('<div class="node-container" id="add-node-' + floorVal + '"><input type="button" value="Add a Node" onClick="addNode(' + floorVal + ')"></div>');
        }

        function nodeDetails(arrayIndex){
            const node = pointArray[arrayIndex];
            const nodeDiv = '<div class="node-container">' +
                                '<span><input id="nodename-' + arrayIndex + '" type="text" value="' + node.name + '"></span>' +
                                '<span><input type="button" value="Update Node" onclick="updateNodeDetails(' + arrayIndex + ')"></span>' +
                                '<span><input type="button" value="Delete Node" onclick="deleteNode(' + arrayIndex + ')"></span>' +
                                '<div>' +
                                    '<span>X<input id="nodex-' + arrayIndex + '" class="pos-input" type="number" value="' + node.x + '"></span>' +
                                    '<span>Y<input id="nodey-' + arrayIndex + '" class="pos-input" type="number" value="' + node.y + '"></span>' +
                                    '<span>Z<input id="nodez-' + arrayIndex + '" class="pos-input" type="number" value="' + node.z + '"></span>' +
                                    '<span><input type="button" value="Configure Connected Nodes" onclick="setConnectedNodes(' + arrayIndex + ')"></span>' +
                                '</div>' +
                            '</div>'
            $(".floor-" + node.floor + "-content").append(nodeDiv);
        }

        function updateNodeDetails(arrayIndex){
            const xString = "#nodex-" + arrayIndex;
            const yString = "#nodey-" + arrayIndex;
            const zString = "#nodez-" + arrayIndex;
            const nameString = "#nodename-" + arrayIndex;
            const xNew = parseInt($(xString).val());
            const yNew = parseInt($(yString).val());
            const zNew = parseInt($(zString).val());
            const newName = $(nameString).val();
            pointArray[arrayIndex].updateCoordinates(xNew, yNew, zNew);
            changeNodeName(arrayIndex, newName);
        }

        function changeNodeName(arrayIndex, newName){
            var oldName = pointArray[arrayIndex].name;
            for(var i = 0; i < pointArray.length; i++){
                for(var j = 0; j < pointArray[i].connectedPoints.length; j++){
                    if(pointArray[i].connectedPoints[j] === oldName) pointArray[i].connectedPoints[j] = newName;
                }
            }
            pointArray[arrayIndex].name = newName;
        }

        function deleteNode(arrayIndex){
            pointArray[arrayIndex].removeReferences(pointArray, geometryLines);
            pointArray.splice(arrayIndex, 1);

            $(".point-list").empty();
            for(var i = 0; i < floorCount; i++){
                floorDetails(i);
            }
            $(".point-list").append('<div class="floor-container" id="add-floor"><input type="button" value="Add a Floor" onClick="addFloor()"></div>');
        }

        function setConnectedNodes(arrayIndex){
            $('#current-node-parent').attr('value', arrayIndex);
            $(".connected-node-options").empty();
            $(".connected-node-options").append('Parent Node: ' + pointArray[arrayIndex].name + '<br>');
            for(var n = 0; n < pointArray.length; n++){
                if(n != arrayIndex){
                    var name = pointArray[n].name;
                    var checkboxString = '<input type="checkbox" name="chk[]" value="' + name + '">' + name + '<br>';
                    $(".connected-node-options").append(checkboxString);
                }
            }
            var connected = pointArray[arrayIndex].connectedPoints;
            $('input[name="chk[]"]').each(function(){
                var isChecked = false;
                var reference = $(this);
                for(var n = 0; n < connected.length; n++){
                    if(connected[n] === reference.val()) isChecked = true;
                }
                if(isChecked) reference.prop('checked', true);
            })
            $("#nodeModal").modal();
        }

        function updateConnectedNodes(){
            var parentNode = parseInt($('#current-node-parent').val());
            var newConnected = [];
            $('input[name="chk[]"]:checked').each(function(){
                newConnected.push($(this).val())
            })
            pointArray[parentNode].connectedPoints = newConnected;
            for(var i = 0; i < pointArray.length; i++){
                for(var j = 0; j < newConnected.length; j++){
                    if(pointArray[i].name === newConnected[j]){
                        var alreadyConnected = false;
                        for(var k = 0; k < pointArray[i].connectedPoints.length; k++){
                            if(pointArray[i].connectedPoints[k] === pointArray[parentNode].name) alreadyConnected = true;
                        }
                        if(!alreadyConnected){
                            pointArray[i].connectedPoints.push(pointArray[parentNode].name);
                        }
                    }
                }
            }
            geometryLines.length = 0;
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            init();
            $("#nodeModal").modal('hide');
        }

        function onDocumentMouseDown(event){
            mouse.x = ( (event.clientX - renderer.domElement.offsetLeft) / renderer.domElement.width) * 2 - 1;
            mouse.y = - ( (event.clientY - renderer.domElement.offsetTop) / renderer.domElement.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            var intersects = raycaster.intersectObjects(targetList);

            if (intersects.length > 0) {
                isAnimating = false;
                console.log(intersects[0].object.name);
                setHighlight(intersects[0].object);
            }
        }

        function setHighlight(object){
            scene.remove(scene.getObjectByName('highlight'));

            var highlightGeometry = new THREE.SphereGeometry(20, 32, 32);
            var highlightMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            highlightMaterial.transparent = true;
            highlightMaterial.opacity = 0.5;

            var highlightSphere = new THREE.Mesh(highlightGeometry, highlightMaterial);
            highlightSphere.position.setX(object.position.x);
            highlightSphere.position.setY(object.position.y);
            highlightSphere.position.setZ(object.position.z);
            highlightSphere.name = 'highlight';

            scene.add(highlightSphere);
        }

        $(".array-name").on('keypress', function(e){
            if(e.which == 13){
                arrayName = $(".array-name").val();
                $(".point-list").empty();
                pointArray.length = 0;
                geometryLines.length = 0;
                targetList.length = 0;
                while(scene.children.length > 0){
                    scene.remove(scene.children[0]);
                }
                updateExistingArray();
                init();
            }
        });

        $(".submit-temp").on('click', function(e){
            $(".point-list").empty();
            pointArray.length = 0;
            geometryLines.length = 0;
            targetList.length = 0;
            while(scene.children.length > 0){
                scene.remove(scene.children[0]);
            }
            generateArray();
            init();
        });

        $(".animation-toggle").on('click', function(e){
            if(!isAnimating){
                $(".animation-toggle").val("Pause");
                scene.remove(scene.getObjectByName('highlight'));
             }
             else{
                 $(".animation-toggle").val("Play");
             }
            isAnimating = !isAnimating;
        });

        $(".load-file").on('click', function(e){
            loadAnimationFile();
            isAnimating = false;
        });

        $("#time-slider").on('change', function(e){
            currentTime = $("#time-slider").val();
        });

        canvas.addEventListener('click', onDocumentMouseDown, false);
        animate();
    </script>
</body>
</html>